// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"
)

const filename = "config/doc.go"

func main() {
	fmt.Printf("Generating %s...\n", filename)
	f, err := os.Create(filename)
	die(err)
	defer f.Close()

	fs := token.NewFileSet()
	reg := map[string][]field{}
	v := visitor{
		reg:          &reg,
		maxDepth:     2,
		onlyExported: true,
	}

	files := []string{}
	err = filepath.Walk(".", func(path string, f os.FileInfo, err error) error {
		files = append(files, path)
		return nil
	})
	die(err)

	for _, file := range files {
		if strings.Contains(file, "vendor") || strings.HasSuffix(file, "_test.go") || !strings.HasSuffix(file, ".go") {
			continue
		}
		f, err := parser.ParseFile(fs, file, nil, parser.ParseComments)
		if err != nil {
			// Ignore if file could not be read
			continue
		}
		ast.Walk(v, f)
	}

	out, err := v.renderMap("config.ConfigSection", "config")

	_, err = f.Write([]byte(out))
	die(err)
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

type visitor struct {
	// configuration
	onlyExported bool
	maxDepth     int
	depth        int

	// store
	cp  string // store the current package to be parsed
	cs  string // store the current struct to be parsed
	reg *map[string][]field
}

func (v visitor) asMap(root string) map[string]string {
	out := map[string]string{}
	if next, ok := (*v.reg)[root]; ok {
		for _, f := range next {
			out[f.tag] = f.doc
			children := v.asMap(f.typ)
			for k, v := range children {
				out[f.tag+"."+k] = v
			}
		}
	}
	return out
}

func (v visitor) renderMap(root string, pkg string) (string, error) {
	docs := v.asMap(root)

	data := struct {
		Pkg       string
		Docs      map[string]string
		Timestamp time.Time
	}{
		Pkg:       pkg,
		Docs:      docs,
		Timestamp: time.Now(),
	}

	templ := `// Code generated by go generate; DO NOT EDIT.

package {{ .Pkg }}

func configDoc(section string) map[string]string {
	doc := make(map[string]string)
	doc[section] = ` + "`" + `The default section is - as the name suggests - read by default. Note the '&default'
notation; this is known an an 'anchor' and allows you to reuse the settings
in other sections...` + "`" + `
	{{- range $key, $doc := .Docs}}
	doc[section+".{{$key}}"] = ` + "`{{ $doc }}`" + `
	{{- end}}
	return doc
}
`
	tmpl, err := template.New("").Parse(templ)
	if err != nil {
		return "", err
	}
	var buffer bytes.Buffer
	if err = tmpl.Execute(&buffer, data); err != nil {
		return "", err
	}
	return buffer.String(), nil
}

func (v visitor) addField(f field) {
	(*v.reg)[v.cp+"."+v.cs] = append((*v.reg)[v.cp+"."+v.cs], f)
}

func (v visitor) Visit(n ast.Node) ast.Visitor {
	// Exit if node is nil. Also there is no need to go deeper than on field
	// level of a globally defined sturct eg. maxDepth = 3.
	if n == nil || v.depth > v.maxDepth {
		return nil
	}

	switch n := n.(type) {
	case *ast.File:
		v.cp = n.Name.Name
		v.depth++
	case *ast.TypeSpec:
		if v.onlyExported && !n.Name.IsExported() {
			return nil
		}
		v.cs = n.Name.Name
		v.depth++
	case *ast.Field:
		if len(n.Names) > 0 {
			fi := NewFieldFromField(n, v.cp)
			v.addField(fi)
		}
		v.depth++
	}
	return v
}

type field struct {
	name    string
	typ     string
	typMeta string
	tag     string
	doc     string
}

func NewFieldFromField(f *ast.Field, pac string) field {
	typ, typMeta := GetFieldType(f, pac)
	return field{
		name:    f.Names[0].String(),
		typ:     typ,
		typMeta: typMeta,
		tag:     getYAMLTag(f),
		doc:     f.Doc.Text(),
	}
}

func GetFieldType(f *ast.Field, pac string) (typ string, typMeta string) {
	switch o := f.Type.(type) {
	case *ast.ArrayType:
		typ = "Array"
	case *ast.MapType:
		typ = "Map"
	case *ast.Ident:
		typ = fmt.Sprintf("%s.%s", pac, o.Name)
	case *ast.SelectorExpr:
		i := getExprAsIdent(o.X)
		x := i.Name
		typ = fmt.Sprintf("%s.%s", x, o.Sel.Name)
	default:
		typ = "Unknown"
		typMeta = fmt.Sprintf("Content: %s - Type: %#T", o, o)
	}
	return
}

func getExprAsIdent(in ast.Expr) *ast.Ident {
	switch e := in.(type) {
	case *ast.Ident:
		return e
	default:
		fmt.Printf("%#v %#T", e, e)
	}
	return nil
}

func (f field) String() string {
	out := fmt.Sprintf("%s | Type: %s | Tag: %s", f.name, f.typ, f.tag)
	return out
}

var yamlTagRE = regexp.MustCompile(`yaml:"(?P<tag>\w+)"`)

func getYAMLTag(f *ast.Field) string {
	out := ""
	tags := f.Tag
	if tags == nil {
		return out
	}
	matches := yamlTagRE.FindStringSubmatch(tags.Value)
	if len(matches) >= 2 {
		out = matches[1]
	}
	return out
}
